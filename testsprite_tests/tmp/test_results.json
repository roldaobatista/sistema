[
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "54724082-9ed1-4a87-a2f1-6bea460928f8",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC001-Successful user login with correct credentials and tenant selection",
    "description": "Verify that a user can log in successfully using valid email and password, select a tenant if applicable, and access the dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields with valid credentials and click the Entrar (submit) button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with valid credentials and click the 'Entrar' button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected to see the Dashboard (showing KPIs and Recent Activities) after logging in with valid credentials and selecting a tenant if prompted, but the dashboard did not appear — login, tenant selection, or page navigation likely failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301784554//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.653Z",
    "modified": "2026-02-12T12:45:02.863Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "30ee1872-ef44-4be9-9331-66847cd133e8",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC002-Login fails with incorrect credentials",
    "description": "Verify that login is unsuccessful when entering an invalid email or password and an appropriate error message is displayed.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the login page (http://localhost:3000/login) so the login form can be found. If no login UI appears, wait and then try alternative navigation.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try reloading the frontend by navigating to http://localhost:3000 (root) to force the SPA to load, then wait and re-check for login form inputs.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend (http://localhost:8000) in a new tab to verify the API/dev server is running, then inspect its response. After that, return to the frontend and attempt alternative reloads (e.g., /index.html) or report website issue if backend is down.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the frontend login page (http://localhost:3000/login) in a new tab and locate the login form inputs and login button so invalid-credentials submission can be attempted.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load a static entry (index.html) to force the frontend to render so the login form can be found. If the page remains blank, reassess and report website issue.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend in a new tab to verify the API/dev server is running and inspect its response (to help diagnose why the frontend SPA is blank).\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Invalid email or password').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected an error message stating 'Invalid email or password' after submitting invalid credentials, but the message did not appear — login may have succeeded unexpectedly or the UI failed to show the validation error.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301569663//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.658Z",
    "modified": "2026-02-12T12:45:02.895Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "be8dc5c9-ca01-44db-928e-8de092746ad0",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC003-Dashboard KPI and chart data accuracy",
    "description": "Ensure that the dashboard displays correct KPI cards, charts, financial summary, and recent work order information consistent with backend data.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to a developer/login route (http://localhost:3000/login) to find the login form; if not present, attempt other known routes (/dashboard, /index.html, /#/login).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to an alternative route to load the SPA (try http://localhost:3000/index.html) and re-scan the page for login fields or dashboard elements.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading a hash-route (/#/login) to reach the SPA login route or reveal the app. If that fails, continue with other hash routes (/#/dashboard) or report the site load issue.\n        await page.goto(\"http://localhost:3000/#/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health endpoint at http://localhost:8000/health to verify the API is up and reachable. If backend is healthy, then try to load a frontend static asset or error page to gather failure details (e.g., main.js, index.html).\n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Inspect backend root and common alternate health endpoints to locate a working health/status endpoint or API base (try /, /api/health, /healthz).\n        await page.goto(\"http://localhost:8000/\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/healthz\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe frontend dev-server/HMR and static asset endpoints to gather error details (start with http://localhost:3000/@vite/client) in a new tab.\n        await page.goto(\"http://localhost:3000/@vite/client\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open frontend static asset(s) in new tabs to check whether static files are being served (start with /favicon.ico, then /main.js). Gather HTTP responses/content to diagnose why the SPA is blank.\n        await page.goto(\"http://localhost:3000/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000/main.js\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open frontend main bundle (http://localhost:3000/main.js) in a new tab to check whether static JS bundle is being served and to gather error details.\n        await page.goto(\"http://localhost:3000/main.js\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with provided credentials and click Entrar to load the dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the login (click Entrar) and wait for the dashboard to load; after navigation, scan the dashboard for KPI cards, charts, financial summary, and recent work orders.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div/div[2]/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fetch backend canonical data from the API endpoints /api/kpis and /api/ordens (open each in a new tab and extract the full JSON response) so UI values can be compared with backend values.\n        await page.goto(\"http://localhost:8000/api/kpis\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/ordens\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Locate a working backend API endpoint or API docs (try /docs, /swagger, /api/v1/kpis) to retrieve canonical KPI, chart and ordens data for comparison with the UI.\n        await page.goto(\"http://localhost:8000/docs\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/swagger\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v1/kpis\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Locate a working backend API endpoint that returns dashboard/kpi/ordens data (try /api/v1/dashboard) so UI values can be compared with backend canonical data.\n        await page.goto(\"http://localhost:8000/api/v1/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Re-open the frontend dashboard UI in the browser so the visible KPI/cards/charts can be re-extracted (navigate to http://localhost:3000/#/dashboard). If dashboard doesn't load, attempt http://localhost:3000/ or /#/login to get back to the UI. After the UI is loaded, attempt extracting the KPI cards and visible summaries again.\n        await page.goto(\"http://localhost:3000/#/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with credentials and submit (Entrar) to load the dashboard so extraction and backend comparisons can be performed.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email & password) and submit (Entrar) to load the dashboard so KPI/cards/charts/orders can be re-extracted for comparison with backend data.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Financial Summary').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the dashboard to display the Financial Summary and related KPI cards, charts, and recent work orders (reflecting backend data), but the Financial Summary section was not visible — the dashboard may not have loaded or data is missing\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301882733//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.664Z",
    "modified": "2026-02-12T12:45:03.051Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "7b3a17ac-596a-4f72-b7a6-ac0c7ef962cf",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC004-Work order creation and detail verification",
    "description": "Verify creating a new work order with all required fields succeeds and the work order details page displays all entered information accurately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application root (navigate to http://localhost:3000) to attempt to load the SPA. If the page remains blank after reload, attempt direct navigation to a likely entry page (/login or /work-orders).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load a likely entry page by navigating to the login route (/login). If /login also fails to render, try direct /work-orders or report site issue.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt direct navigation to the work orders page (/work-orders) to see if a different route loads the SPA or reveals interactive elements.\n        await page.goto(\"http://localhost:3000/work-orders\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password fields and click the 'Entrar' (submit) button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt login again by filling the email and password fields and clicking 'Entrar' (login attempt 2/3).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Perform final login attempt: correctly fill email and password (clear previous values) and click 'Entrar' to log in so the flow can continue to the work-orders create page.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Check backend / health endpoints (open http://localhost:8000/health in a new tab) to verify API/backend status and identify whether backend is reachable before proceeding with UI actions.\n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check API root to verify backend availability (navigate current tab to http://localhost:8000). If reachable, attempt common health endpoints (/api/health). If backend is down/unreachable, report website issue.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the frontend application at http://localhost:3000 in a new tab and inspect for interactive elements (login/dashboard/work-orders).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload/navigate to the frontend login page to attempt to render the SPA again and wait for it to load. If login UI appears, proceed from there; otherwise use alternate diagnostics.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the frontend at http://localhost:3000 and wait for the SPA to load. If the page remains blank, check backend root and report website issue.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password fields and click 'Entrar' to authenticate so the work order creation flow can continue.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the backend API root (/api) in a new tab to discover available endpoints. If API endpoints for work orders exist, attempt to create and verify a work order via the API because the frontend UI is not reliably rendering.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend API for work order endpoints by navigating to likely API paths (start with /api/work-orders) to see if work order creation is possible via API since the frontend is unstable.\n        await page.goto(\"http://localhost:8000/api/work-orders\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe alternative API route for work orders (try /api/v1/work-orders) to see if work orders can be created via the backend since the frontend UI is unreliable.\n        await page.goto(\"http://localhost:8000/api/v1/work-orders\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Work Order Created Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Tried to create a new work order and verify the success confirmation and detail page. Expected to see 'Work Order Created Successfully' and the work order details (all entered fields and attachments) but the confirmation did not appear — creation likely failed or the UI did not render correctly.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302013451//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.678Z",
    "modified": "2026-02-12T12:45:03.035Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "2a87d248-8255-4f45-8992-6762f72a04f3",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC005-Work order Kanban board status transitions",
    "description": "Verify that work orders can be moved between statuses on the Kanban board and that status transitions are reflected correctly system-wide.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with provided credentials and submit to access the application (to then navigate to Kanban).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the login/Entrando... button (index 84) to ensure credentials are submitted and wait for the app to navigate to the main dashboard so the Kanban board link can be found.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div/div[2]/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form with the discovered credentials (admin@sistema.local / password) and submit by clicking the 'Entrar' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Work order status updated to In Progress').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Tried to move a work order to a different status on the Kanban board and verify the change was reflected system-wide (including the work order detail). Expected the confirmation text 'Work order status updated to In Progress' to appear after the drag-and-drop and refresh, but it did not — the status update was not visible or not persisted.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/17709003022958//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.684Z",
    "modified": "2026-02-12T12:45:03.315Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "c16ee52d-0245-4bb6-a0e4-63c3e68943f9",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC006-Customer creation with valid CNPJ and address lookup",
    "description": "Verify that creating a customer with a valid CNPJ triggers automatic lookup for company details and CEP triggers address autofill, and the customer is saved correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the application UI (wait for load) then navigate directly to the customer creation page if UI doesn't appear.\n        await page.goto(\"http://localhost:3000/customers/create\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load a page with interactive elements (try /login) so authentication or app UI can be reached, then proceed to authenticate if login is required.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application UI to obtain interactive elements (wait briefly then navigate to root). If still blank, try alternate recovery steps (longer wait, check different routes or report site issue).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading a static index route to force the app entrypoint (http://localhost:3000/index.html) and wait for load, then re-check for interactive elements.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend API at http://localhost:8000 in a new tab to check API health/endpoints and confirm whether backend is reachable (helps diagnose frontend blank page).\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the backend customers API endpoint to discover available routes and authentication requirements (GET http://localhost:8000/api/customers).\n        await page.goto(\"http://localhost:8000/api/customers\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend API root at http://localhost:8000/api to list available API endpoints and locate authentication and customer-related routes.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend root (http://localhost:8000) to inspect available links/pages and locate API/auth or customer endpoints so the test can continue via API if frontend remains unavailable.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend auth/CSRF endpoints to discover authentication requirements. Start by requesting /sanctum/csrf-cookie (or equivalent) to establish session cookies and then attempt known API login endpoints if present.\n        await page.goto(\"http://localhost:8000/sanctum/csrf-cookie\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load backend root page to inspect available links and then probe likely API routes: /api/v1/customers (and other likely auth endpoints). If backend root returns welcome page, then request /api/v1/customers to check for API presence.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v1/customers\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend API base for v1 to discover available endpoints and any auth entry points (GET /api/v1). This will determine next steps for authentication and customer creation via API.\n        await page.goto(\"http://localhost:8000/api/v1\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Customer created successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected a 'Customer created successfully' confirmation after entering a valid CNPJ (to auto-populate company details) and a valid CEP (to auto-fill address) and saving the customer, but the confirmation did not appear — the CNPJ/CEP lookups or the save action likely failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301833657//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.690Z",
    "modified": "2026-02-12T12:45:02.780Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "c90be30a-571d-4717-99fa-8cec7241ec16",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC007-Financial transaction processing for accounts receivable",
    "description": "Verify that accounts receivable entries can be created, edited, settled, and reported accurately with multiple payment methods.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to allow the SPA time to load, then navigate directly to the login page (/login) if the root remains blank.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with provided credentials and submit to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the login (Entrar) to load the main application; after successful navigation, locate and open Financeiro -> Contas a Receber (Accounts Receivable) to begin test cases.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div/div[2]/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Retry login by clicking the 'Entrar' button (element index 134) to attempt authentication again and trigger navigation to the main app. If the server error persists, re-evaluate and report connection failure.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Retry login by filling email and password again and clicking the Entrar (submit) button (use elements [220],[221],[223]).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Settlement Completed').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to settle a receivable and expected a confirmation 'Settlement Completed' and a status update to 'Settled'. The confirmation text did not appear, so the settlement or UI update failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302036749//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.697Z",
    "modified": "2026-02-12T12:45:03.116Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "5ca7874f-e1a8-4c75-8a42-3cf9bab3a088",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC008-Expense creation and approval workflow",
    "description": "Verify that new expenses can be created, routed for approval, approved or rejected, and reflected appropriately in expense reports.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with credentials and submit to authenticate (input email, input password, click Entrar).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the login page to reinitialize the SPA and wait for it to load, then re-check for interactive elements (login inputs or dashboard nav).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh tab to the app root to try to load the SPA again, then wait for the app to initialize and check for interactive elements (login or navigation).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form in the current tab with admin@sistema.local and password, then click 'Entrar' to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the Financeiro (Finance) module from the left sidebar to access 'Despesas' (Expenses) and proceed to create a new expense.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[10]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Despesas (Expenses) page by clicking the 'Despesas' link in the Financeiro menu (index 1216).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/div[10]/div/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the application root (http://localhost:3000) in the current tab and wait 3s to let the SPA initialize. After that, check the page for interactive elements (login or dashboard). If SPA loads, navigate to Financeiro -> Despesas (use fresh element indexes). If SPA remains blank, open a new tab to the root as fallback.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh new tab to http://localhost:3000 and wait 3 seconds for the SPA to initialize, then re-check for interactive elements (login or dashboard). If SPA loads, proceed to navigate Financeiro -> Despesas using fresh element indexes.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a fresh new tab to http://localhost:3000 and wait for the SPA to initialize so the expense workflow can be executed (obtain fresh interactive elements).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Expense status: Approved').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected the newly created expense to be marked 'Expense status: Approved' after approval (verifying the approval workflow and that the UI reflects the status), but the label did not appear — the expense may not have been approved or the UI did not update\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302050811//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.703Z",
    "modified": "2026-02-12T12:45:03.041Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "72f879ff-9aa9-4835-88a9-5840fbd13f21",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC009-Quote creation, approval, sending, and conversion to work order",
    "description": "Verify that quotes can be created, edited, approved, sent to customers, and converted into work orders properly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the login page at http://localhost:3000/login (use direct navigation since no clickable navigation elements are present).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form (email + password) and click the 'Entrar' submit button to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Work Order Created Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to convert an approved quote into a work order and verify a confirmation message 'Work Order Created Successfully' appeared, but the confirmation did not appear — conversion or UI notification likely failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302005114//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.709Z",
    "modified": "2026-02-12T12:45:03.029Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "0186687a-e269-4e1b-9726-f5878ffab887",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC010-Service call creation and SLA monitoring",
    "description": "Verify creation of service calls assigned to technicians, status tracking, and SLA compliance is monitored and notifications triggered on violations.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the frontend with a cache-busting parameter to force the SPA to load, then re-check the page for login fields or navigation links (Service Calls / Calls / Field Service).\n        await page.goto(\"http://localhost:3000/?_cb=1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading the static index file (http://localhost:3000/index.html) to force the SPA to render; then re-check the page for login fields or navigation links. If still blank, next plan is to check backend at http://localhost:8000 for service health.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend API (http://localhost:8000) in a new tab to check service health/endpoints (look for /health, /api, /docs or API responses) so next steps can use the API if frontend remains unavailable.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the backend API root at /api to see if an API response or list of endpoints/JSON is available (check for health or docs endpoints).\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for API endpoints that expose service calls or health information. Immediate action: request http://localhost:8000/api/health (then /health and /api/service-calls if needed) to locate usable endpoints for performing the service calls test via API.\n        await page.goto(\"http://localhost:8000/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/service-calls\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional likely backend API endpoints to locate the service calls API or API docs so tests can continue via the backend. Immediate action: request several likely API paths on the backend.\n        await page.goto(\"http://localhost:8000/api/v1\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v1/service-calls\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/calls\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for likely service-calls endpoint at /api/v1/calls to find a usable API route for creating and managing service calls.\n        await page.goto(\"http://localhost:8000/api/v1/calls\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check if frontend is served by Vite on port 5173; if not found, open backend documentation or docs pages (e.g., /docs) in a new tab to find API routes.\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Reload button on the Vite error page to retry loading the frontend, then wait 3 seconds and re-check the page for login fields or navigation links (Service Calls / Calls / Field Service). If the reload fails again, plan to switch to the backend tab and attempt API-based actions to create/assign/update service calls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the backend (http://localhost:8000) in a new tab and probe for usable API endpoints (/api, /health, /api/docs). If an API endpoint for service calls is discovered, prepare to create a service call via the API.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for API documentation/openapi at /openapi.json (check http://localhost:8000/openapi.json) to locate usable API endpoints to perform service-call creation and tests via API.\n        await page.goto(\"http://localhost:8000/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for API documentation at /api/docs to locate usable API endpoints for creating and managing service calls via the API.\n        await page.goto(\"http://localhost:8000/api/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for API documentation (try /swagger.json) to discover usable API endpoints for creating and managing service calls.\n        await page.goto(\"http://localhost:8000/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Service Call Created and Assigned to Technician').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the UI to show 'Service Call Created and Assigned to Technician' after creating and assigning the service call. This was meant to verify the call was created and assigned to a technician (and that SLA tracking/notifications can be monitored); the confirmation did not appear, so creation/assignment or the UI acknowledgement likely failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302489088//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.715Z",
    "modified": "2026-02-12T12:45:03.322Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "961912a2-e014-4c7d-bef8-ac3a5842651c",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC011-Equipment CRUD operations with maintenance and calibration history",
    "description": "Verify equipment records can be created, viewed, updated, and deleted, including maintenance and calibration history association.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the frontend / wait for the SPA to initialize so interactive elements (login/navigation) become available, then locate the equipment management page or login form.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the login page directly by navigating to http://localhost:3000/login to force SPA initialization and reveal interactive elements (login form).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API base URL in a new tab to check service health/endpoints so equipment CRUD tests can proceed via API if the frontend remains inaccessible.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the backend API root (/api) to discover available endpoints. If no response or not informative, try common equipment-related endpoints (/api/equipment, /api/equipments, /api/equipamentos, /api/v1/equipment) to find the equipment CRUD API.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try common equipment-related API endpoints on the backend to locate the equipment CRUD API (start with /api/equipamentos, then /api/equipment, /api/equipments, /api/v1/equipment). If none return a useful response, plan next discovery steps (auth endpoints, routes:list via artisan if accessible).\n        await page.goto(\"http://localhost:8000/api/equipamentos\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/equipment\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/equipments\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the next likely equipment API endpoint: GET http://localhost:8000/api/v1/equipamentos to check for equipment CRUD routes.\n        await page.goto(\"http://localhost:8000/api/v1/equipamentos\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the next likely equipment API endpoint at /api/v1/equipment to continue API discovery.\n        await page.goto(\"http://localhost:8000/api/v1/equipment\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request next likely API endpoints to locate equipment CRUD: GET /api/v1/equipments, then /api/login, /api/auth/login, and /sanctum/csrf-cookie (in that order).\n        await page.goto(\"http://localhost:8000/api/v1/equipments\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/login\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the Sanctum CSRF endpoint (GET /sanctum/csrf-cookie) to check for Sanctum-based auth and any available cookies/headers; this may reveal the API auth mechanism. If it responds, continue API discovery; if it 404s, try API documentation endpoints next.\n        await page.goto(\"http://localhost:8000/sanctum/csrf-cookie\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open likely API documentation endpoints in new tabs to look for route listings: /swagger, /swagger.json, /docs (open each in a new tab).\n        await page.goto(\"http://localhost:8000/swagger\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try two additional likely API discovery endpoints to locate equipment CRUD: /public/api and /api/v2/equipments (open each in a new tab). If these also fail, prepare to report inability to reach equipment API or frontend and request further guidance or access to the backend source/config.\n        await page.goto(\"http://localhost:8000/public/api\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v2/equipments\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Equipment deleted successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to delete the equipment and confirm its removal along with associated maintenance and calibration histories, but the deletion confirmation 'Equipment deleted successfully' did not appear — deletion may have failed or the UI did not update to remove the equipment and its histories.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302106395//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.721Z",
    "modified": "2026-02-12T12:45:03.074Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "20ffbb0e-7ed9-42ef-ad60-a3bdae04cb9a",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC012-CRM pipeline management and customer 360 view",
    "description": "Verify users can create and manage sales deals in pipeline stages, access full customer profile 360 views, and update deal progress.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the application's login or entry route to load the SPA (use /login). If that fails, try other common entry paths.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to an alternative SPA entry route (/app) to attempt to load the CRM UI.\n        await page.goto(\"http://localhost:3000/app\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try loading an alternative SPA entry route that may serve the CRM UI. Use direct navigation to /dashboard since no clickable navigation elements exist on the current blank page.\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load alternative SPA entry route /signin and check for interactive elements (login form or navigation).\n        await page.goto(\"http://localhost:3000/signin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the alternative SPA entry route /auth/login to attempt to load the frontend. If that also fails, check backend API status as a fallback.\n        await page.goto(\"http://localhost:3000/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend API / server status to determine if frontend failure is due to backend or dev server. Open backend root/health endpoint in a new tab and inspect response.\n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend root (http://localhost:8000/) to inspect response and check for API docs or running status before continuing.\n        await page.goto(\"http://localhost:8000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API root at http://localhost:8000/api to check available routes and responses (if that fails, check /api/health and /sanctum/csrf-cookie).\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend CSRF endpoint to check authentication routes and then probe common API versioned paths (start with /sanctum/csrf-cookie).\n        await page.goto(\"http://localhost:8000/sanctum/csrf-cookie\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend root (http://localhost:8000/) to re-check for links, documentation or debugging pages (Laravel welcome) and then use discovered links to probe API or docs. If no API/docs are found, report blocking issue and stop.\n        await page.goto(\"http://localhost:8000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend API documentation or docs endpoint to discover available API routes and confirm whether API provides endpoints needed for CRM operations (open http://localhost:8000/api/docs in a new tab).\n        await page.goto(\"http://localhost:8000/api/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the frontend Vite dev server on port 3000 to determine if the dev server is running and serving assets. Specifically: ping the Vite endpoint (__vite_ping), load index.html and a static asset (favicon) to capture responses. Based on results, decide next steps (check dev server logs or report blocking issue).\n        await page.goto(\"http://localhost:3000/__vite_ping\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000/favicon.ico\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Deal updated successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected to see confirmation 'Deal updated successfully' after creating/updating a deal and assigning it to a pipeline stage; the confirmation did not appear - deal creation/update, pipeline assignment, or navigation to the customer 360 view likely failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301439534//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.727Z",
    "modified": "2026-02-12T12:45:02.619Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "8d73c135-e158-4ec8-815e-61a0914d22f3",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC013-INMETRO data import and lead enrichment",
    "description": "Verify that INMETRO XML and PSIE format files can be imported, parsed, and leads enriched appropriately with integration to operational workflows.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait for the SPA to finish loading; if still blank, force a reload of the app by navigating to http://localhost:3000 to attempt to recover the UI so the import page can be accessed.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the application's login route (http://localhost:3000/login). If that fails, attempt other likely routes or probe the backend.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend at http://localhost:8000 in a new tab to check service availability and health endpoints (e.g., /health, /api/health, /docs). If backend is available, inspect endpoints that expose import or auth status to guide next steps.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend API endpoints for health or docs (e.g., /api, /health, /api/docs) to discover import/auth endpoints that can be used if frontend remains unavailable.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for health/docs/auth/import endpoints (try /health, /api/health, /api/docs, /docs) in new tabs to discover usable API routes.\n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/health\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for likely auth and import endpoints that can be used without the frontend (try CSRF/sanctum, auth login, import endpoints) to continue testing import/parsing if the SPA remains inaccessible.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/sanctum/csrf-cookie\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reach a backend authentication route or auth UI to determine available API endpoints. Open backend login page at /login to check for auth scaffolding or redirects that reveal API endpoints.\n        await page.goto(\"http://localhost:8000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for any API specification or versioned import endpoints (try /openapi.json and /api/v1/imports) to discover usable import/auth endpoints so import can proceed. If those return 404, continue probing alternate likely endpoints or report inability to locate API.\n        await page.goto(\"http://localhost:8000/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v1/imports\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for other likely API specification or import endpoints that haven't been tried (swagger.json and other variant import routes). Open these in new tabs so responses can be inspected.\n        await page.goto(\"http://localhost:8000/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/swagger-ui\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/v2/imports\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the frontend index file (http://localhost:3000/index.html) in a new tab to check whether the Vite dev server is serving the app bundle or static assets. If that fails, attempt to load a common frontend asset (e.g., main.js) or report inability to access the frontend.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the Vite dev server and frontend static assets to diagnose why index.html is blank. First check the Vite client endpoint (@vite/client); if available, fetch the main JS bundle next.\n        await page.goto(\"http://localhost:3000/@vite/client\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Work Order Created').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected a 'Work Order Created' confirmation after importing INMETRO XML and PSIE files (verifying parsing and lead enrichment) and converting the enriched lead to an actionable work order, but the confirmation did not appear — import/parse/enrichment/conversion likely failed or the UI/backend is unavailable\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301764136//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.733Z",
    "modified": "2026-02-12T12:45:02.776Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "51400751-7a1c-45e6-bcfc-f333c6c6eab3",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC014-IAM user and role management enforcement",
    "description": "Verify that user creation, role assignment, permission matrix enforcement, and audit logging work properly to control access and record changes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with admin credentials and submit to authenticate (proceed to IAM user management).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the IAM/User Management page. Use direct route /#/users since no clickable navigation elements are present.\n        await page.goto(\"http://localhost:3000/#/users\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application root to force the SPA to render, then wait and re-check interactive elements (login/users UI). If still blank, try alternative navigation (/#/login) or inspect backend endpoints.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab to the backend API (http://localhost:8000) to check health and available IAM endpoints so tests can proceed via API if the frontend remains unusable.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the backend API root (/api) to discover available API endpoints and documentation so tests can proceed via API since the frontend is unstable.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Discover API documentation or versioned endpoints for IAM by checking common API doc routes: /api/docs, /api/swagger, /api/v1, /api/v1/users. Start with /api/docs.\n        await page.goto(\"http://localhost:8000/api/docs\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/swagger\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe for versioned or alternate API routes by loading http://localhost:8000/api/v1 to discover available IAM endpoints (versioned API). If that returns 404, continue probing other common admin API routes.\n        await page.goto(\"http://localhost:8000/api/v1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check the backend for authentication-related endpoints used by Laravel (Sanctum/csrf) and other common API auth/docs paths. Start by loading the backend root and then request /sanctum/csrf-cookie to detect Sanctum and any responses that expose API behavior.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/sanctum/csrf-cookie\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for authentication/IAM API endpoints by requesting /api/auth/login to discover available auth endpoints and response format so tests can continue via API if the frontend remains unusable.\n        await page.goto(\"http://localhost:8000/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend root (http://localhost:8000) to re-check Laravel welcome page for any links or clues and then probe alternative common auth/API endpoints.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for alternative authentication endpoints (try /oauth/token) to discover if Laravel Passport or similar is enabled so IAM operations can be attempted via API.\n        await page.goto(\"http://localhost:8000/oauth/token\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend root (http://localhost:8000) to re-evaluate available endpoints and then probe alternate common admin/API routes (e.g., /api/admin, /api/admin/users, /api/openapi.json). Start by navigating to http://localhost:8000.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe for an admin-scoped API endpoint likely to exist (try /api/admin/users) to discover IAM API routes so tests can proceed via API if frontend remains unusable.\n        await page.goto(\"http://localhost:8000/api/admin/users\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend for remaining likely API routes and documentation by checking /admin and /openapi.json so IAM endpoints or docs can be discovered.\n        await page.goto(\"http://localhost:8000/admin\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=User successfully created!').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected a confirmation that the new IAM user was created and roles were assigned (the UI should display 'User successfully created!'); absence of this message indicates user creation, role assignment, or audit logging did not complete as expected\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302340781//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.739Z",
    "modified": "2026-02-12T12:45:03.348Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "bfb1ae03-5e14-45e9-8ba7-e3f1f5cc1575",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC015-Real-time notifications delivery and read status update",
    "description": "Verify that users receive real-time notifications via WebSocket, can view them in the notification center, and mark them as read.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with admin credentials and submit to access the application UI so notification features can be tested.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form with admin@sistema.local / password and submit to authenticate. After submit, wait for the authenticated UI to load and check for notification elements (notification icon/badge or notification center).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the backend API (http://localhost:8000) in a new tab to look for endpoints to reset rate-limits/unlock the account or to trigger notifications directly.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API root (/api) to discover available endpoints or JSON responses that can be used to trigger/unlock notifications, so notifications can be generated for the frontend tests.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try probing a likely backend endpoint that might trigger or list notifications: navigate to http://localhost:8000/api/notifications to check for a notifications API or trigger.\n        await page.goto(\"http://localhost:8000/api/notifications\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe a likely debug/test endpoint to trigger or inspect notifications by navigating to http://localhost:8000/api/test/notify.\n        await page.goto(\"http://localhost:8000/api/test/notify\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional backend endpoints that might trigger notifications or reveal debug routes. Try /api/debug/notify and /api/notify next.\n        await page.goto(\"http://localhost:8000/api/debug/notify\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/notify\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe backend debug/dashboard endpoints that might allow unlocking the account or triggering notifications. Start by opening /horizon on the backend (http://localhost:8000/horizon).\n        await page.goto(\"http://localhost:8000/horizon\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional backend debug/dashboard endpoints that might allow triggering notifications or provide clues (try /telescope and /_debugbar), then return to the frontend (http://localhost:3000) to inspect the login page status and any 'Too Many Attempts' banner.\n        await page.goto(\"http://localhost:8000/telescope\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/_debugbar\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend root in a new tab (http://localhost:8000) and continue probing debug/dashboard endpoints to find an account-unlock or notification-trigger endpoint (/telescope, /horizon, /_debugbar, /_wdt).\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional backend debug endpoints that commonly exist in Laravel installs to find an account-unlock or notification-trigger route (_ignition, ignition health) and check for a backend login page. If those fail, continue probing other likely admin/debug paths. After probing backend, return to frontend (http://localhost:3000) to check login/lockout status.\n        await page.goto(\"http://localhost:8000/_ignition\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/_ignition/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the frontend at http://localhost:3000, wait for the SPA/login to render, then inspect the page for the login form and any 'Too Many Attempts' banner or notification-related UI elements. If login form present, record interactive element indices for email, password, and submit.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend login/admin page to look for an admin interface or debug endpoint that can unlock the account or trigger notifications (will probe backend pages from there).\n        await page.goto(\"http://localhost:8000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the frontend at http://localhost:3000 in this tab, wait for the SPA to load, then inspect the page for the login form and any 'Too Many Attempts' banner or notification UI. Record interactive element indices for email, password and submit if present.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend root in a new tab and continue probing backend debug/admin endpoints to find an account-unlock or notification-trigger route (examples to try next: /_wdt, /_debugbar, /admin, /notify, /api/debug). If backend root reveals links, follow them instead of blind probing.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe a few additional likely backend endpoints that were not tried yet (_wdt, /notify, /admin) to look for an unlock or notification trigger route. After probing, report results and, if still not found, return to frontend to re-check login/lockout banner.\n        await page.goto(\"http://localhost:8000/_wdt\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/notify\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/admin\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302387209//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.745Z",
    "modified": "2026-02-12T12:45:03.279Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "03736ac5-9338-45bc-ac18-974854ecaa12",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC016-Report generation with filter application and CSV export",
    "description": "Verify that reports can be generated with multiple filters applied, data is accurate, and reports can be exported in CSV format successfully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields with provided credentials and click the Entrar (submit) button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the main navigation section likely containing reports by clicking the 'Central' menu item to reveal subitems and look for a 'Relatórios' or 'Reports' entry.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email and password with admin@sistema.local / password and click the Entrar (submit) button to log in, then wait for dashboard to render.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Report generated successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to generate a filtered report and export it as CSV, and expected to see 'Report generated successfully' to confirm the report generation and export preparation, but that success message did not appear — indicating the report generation or export step failed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900301840097//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.750Z",
    "modified": "2026-02-12T12:45:02.890Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "2d15a7f2-02ae-412b-8766-24267a3865a7",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC017-Technician schedule and cash box management",
    "description": "Verify that technicians can be scheduled, their time entries recorded accurately, and cash box transactions are tracked and reported.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application root page to force the SPA to load (navigate to http://localhost:3000).\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the login route (/login) to attempt to load the SPA (use direct navigation since no interactive elements exist on the current page).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter credentials into the login form and click 'Entrar' to authenticate (input email into index 323, password into index 329, then click index 339).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Wait to allow the rate-limit window to expire, then reattempt signing in by clicking the 'Entrar' submit button (index 339). If the error persists after 2 reattempts, report failure and stop.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index=409) and password (index=410) fields then click the submit button (index=412) to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Técnicos' (Technicians) management page by clicking the menu button (index 623).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[9]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the application root to recover a fresh DOM (navigate to http://localhost:3000), then re-check interactive elements (look for dashboard menu / 'Técnicos'). If dashboard not visible, navigate to /login. After DOM is recovered, open 'Técnicos' and continue test plan.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly for the SPA to render. If the login form or dashboard appears, proceed with the planned test flow (login if needed). If the page remains blank, navigate directly to /login to force the SPA to initialize and then proceed to login and open 'Técnicos'.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Refresh/reinitialize the SPA DOM by waiting briefly and navigating to the login route to recover interactive elements, then re-check for the dashboard and the 'Técnicos' menu.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Recover the SPA DOM by navigating to /login and waiting for the page to render. If the login form appears, proceed to authenticate using admin@sistema.local / password; after dashboard loads, open 'Técnicos'. Immediate action: navigate to http://localhost:3000/login and wait 3 seconds to allow the SPA to initialize.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application root to recover a fresh DOM and attempt to restore the dashboard/login UI so the technician-management flow can continue.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Recover SPA DOM so the login/dashboard is accessible. Navigate to the login route and wait for initialization; if the login form appears, authenticate using admin@sistema.local / password and then open 'Técnicos'.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend health/status to determine if API/backend issues are causing the frontend instability. Open the backend (http://localhost:8000) in a new tab to inspect response/status, then proceed based on backend availability.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the frontend app (http://localhost:3000) in a new tab and wait for the SPA to initialize so the login/dashboard can be accessed. If the login appears, proceed to authenticate; if the page is blank, capture the fresh DOM and retry alternative navigation.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Log in using admin@sistema.local / password (fill email and password fields and click Entrar). After successful login and dashboard load, open the 'Técnicos' (Technicians) management page to begin scheduling tests.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Técnicos' (Technicians) management page by clicking the menu button.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[9]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Agenda' (Technician schedule) page to add/update schedule entries by clicking the 'Agenda' sidebar link (index 3258).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/div[9]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Técnicos' sidebar menu (fresh DOM) so the 'Agenda' link becomes interactable, then proceed to open the Agenda page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[9]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Agenda' (technician schedule) page to add/update schedule entries by clicking the Agenda sidebar link (index 3915).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/div[9]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Recover the frontend SPA DOM by navigating to the login route and waiting for the UI to render; then re-open 'Técnicos' and open 'Agenda' to continue scheduling tests.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Recover the frontend SPA DOM by opening the frontend root in a fresh tab and waiting for it to initialize; then re-evaluate interactive elements (login/dashboard/sidebar) to continue the test plan.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Recover the frontend SPA DOM (navigate to /login and wait) and re-evaluate interactive elements. If the page remains blank, attempt an alternative recovery (e.g., reload root or open frontend in a new tab) until a stable DOM with interactive elements is available.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Recover a fresh frontend DOM: open the frontend root in a new tab and wait for the SPA to initialize so interactive elements (login/dashboard/sidebar) can be detected. After DOM is recovered, re-evaluate availability of 'Técnicos' -> 'Agenda' links.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Authenticate using admin@sistema.local / password by filling the email and password fields and clicking 'Entrar' so the dashboard can be accessed.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Técnicos' (Technicians) menu to access Agenda/scheduling.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[9]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302326495//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.756Z",
    "modified": "2026-02-12T12:45:03.343Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "4bc2cf77-f29b-4b55-9bdc-f2d4bc75103d",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC018-Bulk import data validation, mapping, and rollback",
    "description": "Verify that CSV/Excel bulk data imports perform validations, allow field mapping, preview the data, and support rollback if errors occur.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page directly at /login and attempt authentication (navigate to http://localhost:3000/login).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the application root (http://localhost:3000) to attempt SPA initialization and surface interactive elements so the bulk import page can be accessed.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load a static entry (index.html) to determine whether Vite/dev server is serving assets (navigate to http://localhost:3000/index.html). If that fails, check backend or report the frontend issue.\n        await page.goto(\"http://localhost:3000/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend API (http://localhost:8000) in a new tab and retrieve the response body to verify the backend is running and to gather endpoints/status that can help continue testing.\n        await page.goto(\"http://localhost:8000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the frontend SPA at the login route to surface the bulk import UI (navigate to http://localhost:3000/login). If the page remains blank, further diagnosis of the frontend dev server or logs will be required.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the backend (http://localhost:8000) in a new tab to retrieve the response body and list available endpoints/status so frontend issue can be diagnosed or alternative API endpoints found.\n        await page.goto(\"http://localhost:8000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend API endpoint /api to list available endpoints or API responses that could be used to continue testing import functionality.\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for API endpoints that implement import functionality by requesting http://localhost:8000/api/v1 (open in a new tab). If that returns 404, iteratively probe other common API paths.\n        await page.goto(\"http://localhost:8000/api/v1\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for import-related API endpoints by requesting candidate routes so API-driven import testing can proceed (since frontend is unavailable). Targets: /api/imports, /api/import, /api/upload.\n        await page.goto(\"http://localhost:8000/api/imports\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/import\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/upload\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to recover connectivity by reloading the current page (click the Reload button) to see if the API/upload endpoint responds and to reveal any actionable UI or error details.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Probe the backend for import-related endpoints by requesting /api/imports (open in a new tab). If that fails, iterate to alternative likely endpoints (/api/import, /api/uploads, /imports, /uploads, /api/bulk).\n        await page.goto(\"http://localhost:8000/api/imports\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional likely backend endpoints for import/upload functionality so API-driven import tests can proceed if the frontend remains unavailable. Immediate step: open candidate endpoints to check availability and responses.\n        await page.goto(\"http://localhost:8000/uploads\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/imports\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/uploads\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for API documentation or discovery endpoints (openapi.json, swagger.json, /api/docs) to find available import API routes so import testing can continue via API.\n        await page.goto(\"http://localhost:8000/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/swagger.json\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe additional backend discovery/health/auth endpoints that were not yet tried to locate import-related API routes. Open each candidate endpoint in a new tab so responses can be inspected: /api-docs, /api/openapi.yaml, /api/documentation, /health, /status, /api/auth/login. If these return useful documentation or endpoints, use them to drive API-based import tests; if not, report inability to proceed and recommend checking frontend dev server and backend routes.\n        await page.goto(\"http://localhost:8000/api-docs\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/openapi.yaml\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8000/api/documentation\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend auth-related endpoint /api/auth/login (in a new tab) to check for authentication API and locate additional API routes useful for import testing. If that fails, iterate to other discovery endpoints (e.g., /health, /status, /api/auth, /sanctum/csrf-cookie).\n        await page.goto(\"http://localhost:8000/api/auth/login\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Import Completed Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Verifying that the bulk CSV/Excel import completed successfully (valid records imported, invalid rows skipped and shown in preview). The success message 'Import Completed Successfully' did not appear, indicating the import did not finish or the UI/backend is unavailable.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302074169//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.762Z",
    "modified": "2026-02-12T12:45:03.161Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "aec802a0-ca58-4d33-9803-c7930f84a131",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC019-System settings persistence for status flows and templates",
    "description": "Verify that changes to system settings including status flow configurations, message templates, tenant and branch management persist and apply correctly across the system.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to reload the frontend by waiting briefly then navigating to the same URL (reload). If the page remains blank, proceed with alternative diagnostics (open a new tab to backend API or report website issue).\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open a new tab to the backend API at http://localhost:8000 to check server status and available endpoints (diagnose why frontend is blank). Then wait briefly for the response.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check backend API endpoints to confirm API is serving expected routes and health status by requesting http://localhost:8000/api (or health/status endpoints).\n        await page.goto(\"http://localhost:8000/api\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check whether a Vite dev server is serving the frontend (common on port 5173). Open a new tab to http://localhost:5173 to see if the frontend is available there or shows diagnostic info.\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Retry loading the frontend dev server by clicking the 'Reload' button on the error page (attempt 2 for http://localhost:5173). If this fails, will consider alternative diagnostics (check ports, open backend endpoints, or report website issue).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the backend (http://localhost:8000) in a new tab to inspect available endpoints and attempt API-based diagnostics/operations since the frontend (ports 3000/5173) is returning empty responses.\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend admin/login or API endpoints to find an interface or endpoints for system settings and authentication (try /admin or /login on backend).\n        await page.goto(\"http://localhost:8000/admin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open backend login page (http://localhost:8000/login) to locate authentication endpoints or web login UI so tests can proceed via the backend or perform API-driven changes if UI remains unavailable.\n        await page.goto(\"http://localhost:8000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Probe the backend for health/diagnostic endpoints to discover API routes that can be used for configuration changes (since the UI is unavailable). Request a likely health endpoint (/health) on the backend to check API availability.\n        await page.goto(\"http://localhost:8000/health\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Discover API endpoints and documentation that expose settings/auth routes by requesting the API specification (if available) at /api/openapi.json so tests can continue via backend API since the frontend is unavailable.\n        await page.goto(\"http://localhost:8000/api/openapi.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to find API documentation or developer docs on the backend (common paths like /docs or /swagger) so tests can continue via API since frontend is unavailable.\n        await page.goto(\"http://localhost:8000/docs\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try opening the frontend dev server using 127.0.0.1 on port 5173 in a new tab to check whether Vite is reachable (use a different host form). If that fails, attempt 127.0.0.1:3000 or report website issue and request frontend dev server to be started.\n        await page.goto(\"http://127.0.0.1:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt one final reload of the frontend dev server at 127.0.0.1:5173 by clicking the Reload button (index 74). If the page loads, proceed to find/login to the application and then navigate to System Settings. If it remains unavailable, report website issue and switch to API-based diagnostics (if API endpoints become available).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the backend at http://localhost:8000 in a new tab and inspect the root page so API-based diagnostics and configuration can proceed (since the frontend on 3000/5173 remains unavailable).\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Documentation link on the backend welcome page to search for API docs or developer documentation that could provide endpoints or instructions to modify settings via API (click element index 64).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/main/div[1]/ul[1]/li[1]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=System settings saved successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected a confirmation that system settings were saved and applied ('System settings saved successfully'). The test was verifying that changes to status flows, message templates, and tenant/branch details persisted and became active across the system, but the confirmation text did not appear (UI may be unavailable or changes were not persisted).\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302025558//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.769Z",
    "modified": "2026-02-12T12:45:03.075Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "8732cd9e-9cdb-42dd-af8a-4cf9cde7d9bf",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC020-Customer portal order tracking and invoice viewing",
    "description": "Verify customers can log into the portal to view work order statuses, quotes, invoices, and complete satisfaction surveys accurately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields with the stored credentials and click the Entrar (submit) button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Financeiro section to find invoices (click the 'Financeiro' navigation button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/div[10]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Contas a Receber' link (index 1307) under Financeiro to open the invoices list and then extract the first invoice details for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/aside/nav/div[10]/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'Entrar' to log in and load the dashboard so tests can continue (then re-open Financeiro → Contas a Receber).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@sistema.local')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Contas a Receber').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that after logging in and navigating to Financeiro → Contas a Receber the invoices list heading 'Contas a Receber' would be visible, indicating invoices are accessible, but that heading did not appear — navigation or display of invoices failed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302041689//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.775Z",
    "modified": "2026-02-12T12:45:03.113Z"
  },
  {
    "projectId": "8c87d18a-809c-4240-93b4-9a0d60db35a8",
    "testId": "ea5885af-c489-44cf-92cf-78ae9e79b377",
    "userId": "7448b4a8-4031-70e3-a7ed-d0969f0df46f",
    "title": "TC021-PWA installation prompt and offline support functionality",
    "description": "Verify that the application supports PWA installation prompts correctly and that offline mode allows access to cached data and functionality.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check for a web app manifest and service worker by requesting /manifest.json (and then inspect service worker file) since the page has no interactive elements to click. This will determine if PWA assets are present even if the SPA UI failed to render.\n        await page.goto(\"http://localhost:3000/manifest.json\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Request the service worker script at /sw.js to determine if a service worker is registered and available for offline support.\n        await page.goto(\"http://localhost:3000/sw.js\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Cached data loaded (offline)').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the PWA to provide offline access to previously cached data (verifying service worker and cache functionality). The success indicator 'Cached data loaded (offline)' was not found, so the app may not have served cached content or the service worker did not install/respond.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/7448b4a8-4031-70e3-a7ed-d0969f0df46f/1770900302075532//tmp/test_task/result.webm",
    "created": "2026-02-12T12:14:48.781Z",
    "modified": "2026-02-12T12:45:03.093Z"
  }
]
